// Stubbed to unblock build. Restore real implementation after app runs.
import 'dart:io';
import 'dart:typed_data';
      // Generate share text
      final shareText = ContentSharingHelper.generateShareText(
        contentType: 'post',
        content: post.content,
        authorName: post.authorName,
        // customMessage: customMessage, // Remove undefined parameter
      );
      
      final deepLink = ContentSharingHelper.generateDeepLink(
        type: 'post', // Fix parameter name
        id: post.id, // Fix parameter name
        queryParams: { // Fix parameter name
          'utm_source': 'app_share',
          'utm_campaign': 'post_sharing',
        },
      ); as ui;
import 'package:flutter/material.dart';
import 'package:flutter/rendering.dart';
import 'package:share_plus/share_plus.dart';
import 'package:path_provider/path_provider.dart';
import '../../../features/social/domain/entities/post.dart';
import '../../../features/profile/domain/entities/user_profile.dart';
import '../../helpers/social_helpers/content_sharing_helper.dart';
import '../../enums/social_enums.dart';

/// Share result data
class ShareResult {
  final bool success;
  final String? error;
  final String? platform;
  final Map<String, dynamic>? analytics;
  
  const ShareResult({
    required this.success,
    this.error,
    this.platform,
    this.analytics,
  });
}

/// Share queue item for failed shares
class ShareQueueItem {
  final String id;
  final String contentType;
  final Map<String, dynamic> shareData;
  final DateTime createdAt;
  final int retryCount;
  final String? lastError;
  
  const ShareQueueItem({
    required this.id,
    required this.contentType,
    required this.shareData,
    required this.createdAt,
    this.retryCount = 0,
    this.lastError,
  });
  
  ShareQueueItem copyWith({
    int? retryCount,
    String? lastError,
  }) {
    return ShareQueueItem(
      id: id,
      contentType: contentType,
      shareData: shareData,
      createdAt: createdAt,
      retryCount: retryCount ?? this.retryCount,
      lastError: lastError ?? this.lastError,
    );
  }
}

/// Mixin for widgets that need sharing functionality
mixin SocialSharingMixin<T extends StatefulWidget> on State<T> {
  /// Share queue for retry functionality
  final List<ShareQueueItem> _shareQueue = [];
  
  /// Cache for share images
  final Map<String, String> _imageCache = {};
  
  /// Animation controller for share feedback
  AnimationController? _shareAnimationController;
  Animation<double>? _shareAnimation;
  
  /// Share analytics tracking
  final Map<String, dynamic> _shareAnalytics = {};
  
  @override
  void initState() {
    super.initState();
    _initializeShareAnimation();
    _loadShareQueue();
  }
  
  @override
  void dispose() {
    _shareAnimationController?.dispose();
    _saveShareQueue();
    super.dispose();
  }
  
  /// Initialize share animation controller
  void _initializeShareAnimation() {
    _shareAnimationController = AnimationController(
      duration: const Duration(milliseconds: 300),
      vsync: this as TickerProvider,
    );
    
    _shareAnimation = Tween<double>(
      begin: 1.0,
      end: 1.2,
    ).animate(CurvedAnimation(
      parent: _shareAnimationController!,
      curve: Curves.elasticOut,
    ));
  }
  
  /// Share a post with full analytics and error handling
  Future<ShareResult> sharePost(
    Post post, {
    String? customMessage,
    List<String>? targetPlatforms,
    bool generatePreview = true,
  }) async {
    try {
      // Start share animation
      _playShareAnimation();
      
      // Generate share content
      final shareText = ContentSharingHelper.generateShareText(
        contentType: 'post',
        content: post.content,
        authorName: post.author?.displayName ?? post.author?.username ?? 'User',
        customMessage: customMessage,
      );
      
      final deepLink = ContentSharingHelper.generateDeepLink(
        contentType: 'post',
        contentId: post.id,
        additionalParams: {
          'utm_source': 'app_share',
          'utm_campaign': 'post_sharing',
        },
      );
      
      // Generate preview if requested
      String? previewImagePath;
      if (generatePreview) {
        previewImagePath = await _generateSharePreview(post);
      }
      
      // Share content
      final result = await ContentSharingHelper.shareContent(
        text: '$shareText\n\n$deepLink',
        imagePaths: previewImagePath != null ? [previewImagePath] : null,
        subject: 'Check out this post!',
      );
      
      // Track analytics
      _trackShareAnalytics('post', post.id, success: true);
      
      // Show success feedback
      _showShareFeedback('Post shared successfully!', isSuccess: true);
      
      return ShareResult(
        success: true,
        analytics: {
          'content_type': 'post',
          'content_id': post.id,
          'has_preview': previewImagePath != null,
          'share_time': DateTime.now().toIso8601String(),
        },
      );
    } catch (e) {
      // Queue for retry
      _queueFailedShare('post', {
        'post_id': post.id,
        'custom_message': customMessage,
        'target_platforms': targetPlatforms,
        'generate_preview': generatePreview,
      }, e.toString());
      
      // Track failure
      _trackShareAnalytics('post', post.id, success: false, error: e.toString());
      
      // Show error feedback
      _showShareFeedback('Failed to share post', isSuccess: false);
      
      return ShareResult(
        success: false,
        error: e.toString(),
      );
    }
  }
  
  /// Share user profile
  Future<ShareResult> shareUserProfile(
    UserProfile user, {
    String? customMessage,
  }) async {
    try {
      _playShareAnimation();
      
      final shareText = ContentSharingHelper.generateShareText(
        contentType: 'profile',
        content: user.bio ?? '',
        authorName: user.displayName ?? user.username,
        customMessage: customMessage,
      );
      
      final deepLink = ContentSharingHelper.generateDeepLink(
        contentType: 'profile',
        contentId: user.id,
      );
      
      await ContentSharingHelper.shareContent(
        text: '$shareText\n\n$deepLink',
        subject: 'Check out ${user.displayName ?? user.username}\'s profile!',
      );
      
      _trackShareAnalytics('profile', user.id, success: true);
      _showShareFeedback('Profile shared successfully!', isSuccess: true);
      
      return const ShareResult(success: true);
    } catch (e) {
      _queueFailedShare('profile', {
        'user_id': user.id,
        'custom_message': customMessage,
      }, e.toString());
      
      _trackShareAnalytics('profile', user.id, success: false, error: e.toString());
      _showShareFeedback('Failed to share profile', isSuccess: false);
      
      return ShareResult(success: false, error: e.toString());
    }
  }
  
  /// Share achievement
  Future<ShareResult> shareAchievement(
    Map<String, dynamic> achievement, {
    String? customMessage,
  }) async {
    try {
      _playShareAnimation();
      
      final achievementText = 'üèÜ New Achievement Unlocked!\n'
          '${achievement['title'] ?? 'Achievement'}\n'
          '${achievement['description'] ?? ''}';
      
      final shareText = customMessage != null 
          ? '$customMessage\n\n$achievementText'
          : achievementText;
      
      final deepLink = ContentSharingHelper.generateDeepLink(
        contentType: 'achievement',
        contentId: achievement['id']?.toString() ?? '',
      );
      
      await ContentSharingHelper.shareContent(
        text: '$shareText\n\n$deepLink',
        subject: 'Achievement Unlocked!',
      );
      
      _trackShareAnalytics('achievement', achievement['id']?.toString() ?? '', success: true);
      _showShareFeedback('Achievement shared!', isSuccess: true);
      
      return const ShareResult(success: true);
    } catch (e) {
      _queueFailedShare('achievement', {
        'achievement': achievement,
        'custom_message': customMessage,
      }, e.toString());
      
      _trackShareAnalytics('achievement', achievement['id']?.toString() ?? '', success: false, error: e.toString());
      _showShareFeedback('Failed to share achievement', isSuccess: false);
      
      return ShareResult(success: false, error: e.toString());
    }
  }
  
  /// Generate share preview card for content
  Future<String?> _generateSharePreview(Post post) async {
    try {
      // Check cache first
      final cacheKey = 'post_${post.id}';
      if (_imageCache.containsKey(cacheKey)) {
        return _imageCache[cacheKey];
      }
      
      // Create a widget for the share preview
      final previewWidget = _buildSharePreviewCard(post);
      
      // Convert widget to image
      final imagePath = await _widgetToImage(previewWidget, cacheKey);
      
      // Cache the result
      if (imagePath != null) {
        _imageCache[cacheKey] = imagePath;
      }
      
      return imagePath;
    } catch (e) {
      debugPrint('Failed to generate share preview: $e');
      return null;
    }
  }
  
  /// Build share preview card widget
  Widget _buildSharePreviewCard(Post post) {
    return Container(
      width: 400,
      height: 200,
      decoration: BoxDecoration(
        color: Theme.of(context).cardColor,
        borderRadius: BorderRadius.circular(12),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withOpacity(0.1),
            blurRadius: 10,
            offset: const Offset(0, 2),
          ),
        ],
      ),
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            // Header with user info
            Row(
              children: [
                CircleAvatar(
                  radius: 20,
                  backgroundImage: post.author?.avatarUrl != null
                      ? NetworkImage(post.author!.avatarUrl!)
                      : null,
                  child: post.author?.avatarUrl == null
                      ? Text(post.author?.username.substring(0, 1).toUpperCase() ?? 'U')
                      : null,
                ),
                const SizedBox(width: 12),
                Expanded(
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Text(
                        post.author?.displayName ?? post.author?.username ?? 'User',
                        style: const TextStyle(
                          fontWeight: FontWeight.bold,
                          fontSize: 16,
                        ),
                      ),
                      Text(
                        '@${post.author?.username ?? 'username'}',
                        style: TextStyle(
                          color: Colors.grey[600],
                          fontSize: 14,
                        ),
                      ),
                    ],
                  ),
                ),
              ],
            ),
            const SizedBox(height: 16),
            
            // Content
            Expanded(
              child: Text(
                post.content.length > 120 
                    ? '${post.content.substring(0, 120)}...'
                    : post.content,
                style: const TextStyle(fontSize: 14),
                maxLines: 4,
                overflow: TextOverflow.ellipsis,
              ),
            ),
            
            // Footer with stats
            Row(
              children: [
                _buildStatChip(Icons.favorite, post.likesCount),
                const SizedBox(width: 12),
                _buildStatChip(Icons.chat_bubble, post.commentsCount),
                const SizedBox(width: 12),
                _buildStatChip(Icons.share, post.sharesCount),
                const Spacer(),
                Container(
                  padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
                  decoration: BoxDecoration(
                    color: Theme.of(context).primaryColor.withOpacity(0.1),
                    borderRadius: BorderRadius.circular(12),
                  ),
                  child: Text(
                    'Dabbler',
                    style: TextStyle(
                      color: Theme.of(context).primaryColor,
                      fontSize: 12,
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                ),
              ],
            ),
          ],
        ),
      ),
    );
  }
  
  /// Build stat chip for share preview
  Widget _buildStatChip(IconData icon, int count) {
    return Row(
      children: [
        Icon(icon, size: 16, color: Colors.grey[600]),
        const SizedBox(width: 4),
        Text(
          count.toString(),
          style: TextStyle(
            fontSize: 12,
            color: Colors.grey[600],
          ),
        ),
      ],
    );
  }
  
  /// Convert widget to image file
  Future<String?> _widgetToImage(Widget widget, String filename) async {
    try {
      final RenderRepaintBoundary repaintBoundary = RenderRepaintBoundary();
      
      // Create a render object tree
      final RenderView renderView = RenderView(
        configuration: const ViewConfiguration(),
        window: WidgetsBinding.instance.window,
      );
      
      final PipelineOwner pipelineOwner = PipelineOwner();
      renderView.attach(pipelineOwner);
      renderView.prepareInitialFrame();
      
      // Capture the widget as image
      final ui.Image image = await repaintBoundary.toImage(pixelRatio: 2.0);
      final ByteData? byteData = await image.toByteData(format: ui.ImageByteFormat.png);
      
      if (byteData == null) return null;
      
      // Save to temporary directory
      final Directory tempDir = await getTemporaryDirectory();
      final String path = '${tempDir.path}/share_$filename.png';
      final File file = File(path);
      await file.writeAsBytes(byteData.buffer.asUint8List());
      
      return path;
    } catch (e) {
      debugPrint('Failed to convert widget to image: $e');
      return null;
    }
  }
  
  /// Play share animation for user feedback
  void _playShareAnimation() {
    _shareAnimationController?.forward().then((_) {
      _shareAnimationController?.reverse();
    });
  }
  
  /// Show share feedback to user
  void _showShareFeedback(String message, {required bool isSuccess}) {
    if (!mounted) return;
    
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Row(
          children: [
            Icon(
              isSuccess ? Icons.check_circle : Icons.error,
              color: Colors.white,
            ),
            const SizedBox(width: 8),
            Text(message),
          ],
        ),
        backgroundColor: isSuccess ? Colors.green : Colors.red,
        duration: const Duration(seconds: 2),
      ),
    );
  }
  
  /// Track share analytics
  void _trackShareAnalytics(
    String contentType,
    String contentId, {
    required bool success,
    String? error,
  }) {
    final key = '${contentType}_$contentId';
    _shareAnalytics[key] = {
      'content_type': contentType,
      'content_id': contentId,
      'success': success,
      'error': error,
      'timestamp': DateTime.now().toIso8601String(),
    };
    
    // In a real app, send this to analytics service
    debugPrint('Share Analytics: $contentType $contentId - Success: $success');
  }
  
  /// Queue failed share for retry
  void _queueFailedShare(
    String contentType,
    Map<String, dynamic> shareData,
    String error,
  ) {
    final item = ShareQueueItem(
      id: DateTime.now().millisecondsSinceEpoch.toString(),
      contentType: contentType,
      shareData: shareData,
      createdAt: DateTime.now(),
      lastError: error,
    );
    
    _shareQueue.add(item);
    debugPrint('Queued failed share: ${item.id}');
  }
  
  /// Retry failed shares
  Future<void> retryFailedShares() async {
    if (_shareQueue.isEmpty) return;
    
    final itemsToRetry = _shareQueue.where((item) => item.retryCount < 3).toList();
    
    for (final item in itemsToRetry) {
      try {
        // Retry based on content type
        bool success = false;
        
        switch (item.contentType) {
          case 'post':
            // Reconstruct post sharing
            success = true; // Placeholder for actual retry logic
            break;
          case 'profile':
            // Reconstruct profile sharing
            success = true; // Placeholder for actual retry logic
            break;
          case 'achievement':
            // Reconstruct achievement sharing
            success = true; // Placeholder for actual retry logic
            break;
        }
        
        if (success) {
          _shareQueue.remove(item);
          _showShareFeedback('Retry successful!', isSuccess: true);
        } else {
          // Update retry count
          final index = _shareQueue.indexOf(item);
          if (index != -1) {
            _shareQueue[index] = item.copyWith(retryCount: item.retryCount + 1);
          }
        }
      } catch (e) {
        // Update with new error
        final index = _shareQueue.indexOf(item);
        if (index != -1) {
          _shareQueue[index] = item.copyWith(
            retryCount: item.retryCount + 1,
            lastError: e.toString(),
          );
        }
      }
    }
    
    // Remove items that have exceeded retry limit
    _shareQueue.removeWhere((item) => item.retryCount >= 3);
  }
  
  /// Load share queue from storage (placeholder)
  void _loadShareQueue() {
    // In a real implementation, load from persistent storage
    debugPrint('Loading share queue...');
  }
  
  /// Save share queue to storage (placeholder)
  void _saveShareQueue() {
    // In a real implementation, save to persistent storage
    debugPrint('Saving share queue...');
  }
  
  /// Get share animation widget
  Widget buildShareAnimationWrapper(Widget child) {
    if (_shareAnimation == null) return child;
    
    return AnimatedBuilder(
      animation: _shareAnimation!,
      builder: (context, child) {
        return Transform.scale(
          scale: _shareAnimation!.value,
          child: child,
        );
      },
      child: child,
    );
  }
  
  /// Check if sharing is available
  bool get canShare => true; // Platform-specific check would go here
  
  /// Get pending shares count
  int get pendingSharesCount => _shareQueue.length;
  
  /// Clear image cache
  void clearShareImageCache() {
    _imageCache.clear();
  }
  
  /// Get share analytics data
  Map<String, dynamic> get shareAnalytics => Map.from(_shareAnalytics);
}
