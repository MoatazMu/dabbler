// Stubbed to unblock build. Restore real implementation after app runs.
import '../../../features/social/data/models/notification_model.dart';
import '../../../features/social/data/models/user_settings_model.dart';
import '../../enums/social_enums.dart';

/// Action that can be performed on a notification
class NotificationAction {
  final String actionId;
  final String label;
  final bool isPrimary;
  final String? icon;
  
  const NotificationAction(
    this.actionId,
    this.label, {
    this.isPrimary = false,
    this.icon,
  });
}

/// Helper class for notification operations
/// Handles notification formatting, actions, and user preferences
class NotificationHelper {
  /// Gets the appropriate title for a notification
  static String getNotificationTitle(SocialNotification notification) {
    switch (notification.type) {
      case NotificationType.friendRequest:
        return 'New Friend Request';
      case NotificationType.friendAccepted:
        return 'Friend Request Accepted';
      case NotificationType.postLike:
        return 'Someone Liked Your Post';
      case NotificationType.postComment:
        return 'New Comment on Your Post';
      case NotificationType.commentReply:
        return 'New Reply to Your Comment';
      case NotificationType.mention:
        return 'You Were Mentioned';
      case NotificationType.message:
        return 'New Message';
      case NotificationType.gameInvite:
        return 'Game Invitation';
    }
  }
  
  // Stubbed for build unblock
  static String formatNotificationBody(
    SocialNotification notification,
    String actorName,
  ) {
    switch (notification.type) {
      case NotificationType.friendRequest:
        return '$actorName wants to be your friend';
        
      case NotificationType.friendAccepted:
        return '$actorName accepted your friend request';
        
      case NotificationType.postLike:
        return '$actorName liked your post';
        
      case NotificationType.postComment:
        final comment = notification.body?.isNotEmpty == true
            ? ': "${_truncateText(notification.body!, 50)}"'
            : '';
        return '$actorName commented$comment';
        
      case NotificationType.commentReply:
        final reply = notification.body?.isNotEmpty == true
            ? ': "${_truncateText(notification.body!, 50)}"'
            : '';
        return '$actorName replied$reply';
        
      case NotificationType.mention:
        final mention = notification.body?.isNotEmpty == true
            ? ': "${_truncateText(notification.body!, 60)}"'
            : '';
        return '$actorName mentioned you$mention';
        
      case NotificationType.message:
        final message = notification.body?.isNotEmpty == true
            ? _truncateText(notification.body!, 100)
            : 'sent you a message';
        return '$actorName: $message';
        
      case NotificationType.gameInvite:
        final gameInfo = notification.metadata?['game_name'] as String?;
        final gameText = gameInfo != null ? ' to play $gameInfo' : '';
        return '$actorName invited you$gameText';
    }
  }
  
  /// Gets available actions for a notification type
  static List<NotificationAction> getNotificationActions(
    NotificationType type,
  ) {
    switch (type) {
      case NotificationType.friendRequest:
        return [
          const NotificationAction('accept', 'Accept', isPrimary: true, icon: 'check'),
          const NotificationAction('decline', 'Decline', icon: 'close'),
        ];
        
      case NotificationType.message:
        return [
          const NotificationAction('reply', 'Reply', isPrimary: true, icon: 'reply'),
          const NotificationAction('mark_read', 'Mark as Read', icon: 'check'),
        ];
        
      case NotificationType.gameInvite:
        return [
          const NotificationAction('join', 'Join Game', isPrimary: true, icon: 'sports'),
          const NotificationAction('decline', 'Decline', icon: 'close'),
        ];
        
      case NotificationType.postComment:
      case NotificationType.commentReply:
        return [
          const NotificationAction('reply', 'Reply', isPrimary: true, icon: 'reply'),
          const NotificationAction('view', 'View Post', icon: 'visibility'),
        ];
        
      default:
        return [
          const NotificationAction('view', 'View', isPrimary: true, icon: 'visibility'),
        ];
    }
  }
  
  /// Checks if a notification should be shown based on user settings
  static bool shouldShowNotification(
    NotificationType type,
    UserSettings settings,
  ) {
    if (!settings.notificationEnabled) return false;
    
    switch (type) {
      case NotificationType.friendRequest:
      case NotificationType.friendAccepted:
        return settings.friendNotifications;
        
      case NotificationType.postLike:
      case NotificationType.postComment:
      case NotificationType.commentReply:
        return settings.socialNotifications;
        
      case NotificationType.mention:
        return settings.mentionNotifications;
        
      case NotificationType.message:
        return settings.messageNotifications;
        
      case NotificationType.gameInvite:
        return settings.gameNotifications;
    }
  }
  
  /// Groups notifications by time period for better UX
  static Map<String, List<SocialNotification>> groupNotificationsByTime(
    List<SocialNotification> notifications,
  ) {
    final now = DateTime.now();
    final groups = <String, List<SocialNotification>>{
      'Today': [],
      'Yesterday': [],
      'This Week': [],
      'Older': [],
    };
    
    for (final notification in notifications) {
      final age = now.difference(notification.createdAt);
      
      if (age.inDays == 0) {
        groups['Today']!.add(notification);
      } else if (age.inDays == 1) {
        groups['Yesterday']!.add(notification);
      } else if (age.inDays <= 7) {
        groups['This Week']!.add(notification);
      } else {
        groups['Older']!.add(notification);
      }
    }
    
    // Remove empty groups
    groups.removeWhere((key, value) => value.isEmpty);
    
    return groups;
  }
  
  /// Gets the display time for a notification
  static String getNotificationTime(DateTime createdAt) {
    final now = DateTime.now();
    final difference = now.difference(createdAt);
    
    if (difference.inMinutes < 1) {
      return 'Just now';
    } else if (difference.inMinutes < 60) {
      return '${difference.inMinutes}m ago';
    } else if (difference.inHours < 24) {
      return '${difference.inHours}h ago';
    } else if (difference.inDays < 7) {
      return '${difference.inDays}d ago';
    } else {
      return '${createdAt.day}/${createdAt.month}/${createdAt.year}';
    }
  }
  
  /// Generates notification summary for multiple notifications
  static String generateSummary(
    List<SocialNotification> notifications,
    int maxToShow,
  ) {
    if (notifications.isEmpty) return 'No new notifications';
    
    final count = notifications.length;
    if (count == 1) {
      return getNotificationTitle(notifications.first);
    }
    
    // Group by type
    final typeGroups = <NotificationType, int>{};
    for (final notification in notifications) {
      typeGroups[notification.type] = (typeGroups[notification.type] ?? 0) + 1;
    }
    
    final summaryParts = <String>[];
    
    for (final entry in typeGroups.entries) {
      final type = entry.key;
      final typeCount = entry.value;
      
      String typeName;
      switch (type) {
        case NotificationType.friendRequest:
          typeName = typeCount == 1 ? 'friend request' : 'friend requests';
          break;
        case NotificationType.message:
          typeName = typeCount == 1 ? 'message' : 'messages';
          break;
        case NotificationType.postLike:
          typeName = typeCount == 1 ? 'like' : 'likes';
          break;
        case NotificationType.postComment:
          typeName = typeCount == 1 ? 'comment' : 'comments';
          break;
        default:
          typeName = typeCount == 1 ? 'notification' : 'notifications';
      }
      
      summaryParts.add('$typeCount $typeName');
    }
    
    if (summaryParts.length == 1) {
      return '${summaryParts.first} waiting';
    } else if (summaryParts.length == 2) {
      return '${summaryParts[0]} and ${summaryParts[1]} waiting';
    } else {
      return '${summaryParts.take(2).join(', ')} and more waiting';
    }
  }
  
  /// Checks if notification is actionable
  static bool isActionableNotification(NotificationType type) {
    return getNotificationActions(type).isNotEmpty;
  }
  
  /// Gets notification priority level (1-5, 5 being highest)
  static int getNotificationPriority(NotificationType type) {
    switch (type) {
      case NotificationType.friendRequest:
      case NotificationType.gameInvite:
        return 4;
      case NotificationType.message:
        return 3;
      case NotificationType.mention:
      case NotificationType.commentReply:
        return 3;
      case NotificationType.friendAccepted:
      case NotificationType.postComment:
        return 2;
      case NotificationType.postLike:
        return 1;
    }
  }
  
  /// Filters notifications based on user preferences
  static List<SocialNotification> filterNotifications(
    List<SocialNotification> notifications,
    UserSettings settings, {
    bool onlyUnread = false,
    List<NotificationType>? typeFilter,
    Duration? maxAge,
  }) {
    return notifications.where((notification) {
      // Check if should show based on settings
      if (!shouldShowNotification(notification.type, settings)) {
        return false;
      }
      
      // Unread filter
      if (onlyUnread && notification.isRead) {
        return false;
      }
      
      // Type filter
      if (typeFilter != null && !typeFilter.contains(notification.type)) {
        return false;
      }
      
      // Age filter
      if (maxAge != null) {
        final age = DateTime.now().difference(notification.createdAt);
        if (age > maxAge) return false;
      }
      
      return true;
    }).toList();
  }
  
  /// Truncates text to specified length with ellipsis
  static String _truncateText(String text, int maxLength) {
    if (text.length <= maxLength) return text;
    return '${text.substring(0, maxLength)}...';
  }
  
  /// Gets notification badge count
  static int getBadgeCount(
    List<SocialNotification> notifications,
    UserSettings settings,
  ) {
    return filterNotifications(
      notifications,
      settings,
      onlyUnread: true,
      maxAge: const Duration(days: 7), // Only count recent notifications
    ).length;
  }
  
  /// Marks notifications as read
  static List<SocialNotification> markAsRead(
    List<SocialNotification> notifications,
    List<String> notificationIds,
  ) {
    return notifications.map((notification) {
      if (notificationIds.contains(notification.id)) {
        return notification.copyWith(
          isRead: true,
          readAt: DateTime.now(),
        );
      }
      return notification;
    }).toList();
  }
}
