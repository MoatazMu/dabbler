// Stubbed to unblock build. Restore real implementation after app runs.
/// Comprehensive validation classes for image files and URLs
library;
import 'dart:io';
import 'dart:typed_data';
import 'package:image/image.dart' as img;
import 'package:path/path.dart' as path;

/// Image validation utilities for profile pictures, uploads, and media
class ImageValidators {
  // File size constraints
  static const int maxSizeBytes = 5 * 1024 * 1024; // 5MB
  static const int minSizeBytes = 1024; // 1KB minimum
  static const int maxProfileImageSize = 2 * 1024 * 1024; // 2MB for profile pics
  
  // Supported formats
  static const List<String> allowedFormats = ['jpg', 'jpeg', 'png', 'webp'];
  static const List<String> highQualityFormats = ['png', 'webp'];
  
  // Dimension constraints
  static const int minWidth = 150;
  static const int minHeight = 150;
  static const int maxWidth = 4000;
  static const int maxHeight = 4000;
  
  // Profile picture specific constraints
  static const int profileMinSize = 200;
  static const int profileMaxSize = 1500;
  static const int profileRecommendedSize = 500;
  
  // Content validation
  static const List<String> allowedMimeTypes = [
    'image/jpeg',
    'image/jpg', 
    'image/png',
    'image/webp'
  ];
  
  /// Validate image file with comprehensive checks
  static Future<String?> validateImageFile(
    File file, {
    bool isProfilePicture = false,
    bool requireSquare = false,
  }) async {
    try {
      // Check file exists
      if (!await file.exists()) {
        return 'File does not exist';
      }
      
      // Check file size
      final size = await file.length();
      
      if (size < minSizeBytes) {
        return 'Image file is too small (minimum 1KB)';
      }
      
      final maxAllowedSize = isProfilePicture ? maxProfileImageSize : maxSizeBytes;
      if (size > maxAllowedSize) {
        final maxSizeMB = maxAllowedSize / (1024 * 1024);
        return 'Image must be less than ${maxSizeMB.toStringAsFixed(1)}MB';
      }
      
      // Check format by extension
      final extension = path.extension(file.path).toLowerCase().substring(1);
      if (extension.isEmpty) {
        return 'File must have a valid image extension';
      }
      
      if (!allowedFormats.contains(extension)) {
        return 'Only ${allowedFormats.map((f) => f.toUpperCase()).join(', ')} formats are allowed';
      }
      
      // Read and validate image data
      final bytes = await file.readAsBytes();
      final validationResult = await _validateImageBytes(
        bytes, 
        isProfilePicture: isProfilePicture,
        requireSquare: requireSquare,
        filename: file.path,
      );
      
      return validationResult;
      
    } catch (e) {
      return 'Could not process image file: ${e.toString()}';
    }
  }
  
  /// Validate image from bytes data
  static Future<String?> validateImageBytes(
    Uint8List bytes, {
    bool isProfilePicture = false,
    bool requireSquare = false,
    String? filename,
  }) async {
    return _validateImageBytes(
      bytes,
      isProfilePicture: isProfilePicture,
      requireSquare: requireSquare,
      filename: filename,
    );
  }
  
  /// Internal method to validate image bytes
  static Future<String?> _validateImageBytes(
    Uint8List bytes, {
    bool isProfilePicture = false,
    bool requireSquare = false,
    String? filename,
  }) async {
    try {
      // Check bytes size
      if (bytes.isEmpty) {
        return 'Image data is empty';
      }
      
      final maxAllowedSize = isProfilePicture ? maxProfileImageSize : maxSizeBytes;
      if (bytes.length > maxAllowedSize) {
        final maxSizeMB = maxAllowedSize / (1024 * 1024);
        return 'Image must be less than ${maxSizeMB.toStringAsFixed(1)}MB';
      }
      
      // Decode image to check validity and get dimensions
      final image = img.decodeImage(bytes);
      if (image == null) {
        return 'Invalid or corrupted image file';
      }
      
      // Validate dimensions
      final dimensionError = _validateDimensions(
        image.width, 
        image.height,
        isProfilePicture: isProfilePicture,
        requireSquare: requireSquare,
      );
      
      if (dimensionError != null) {
        return dimensionError;
      }
      
      // Check for valid image content (not just renamed file)
      if (!_hasValidImageSignature(bytes)) {
        return 'File does not appear to be a valid image';
      }
      
      // Validate aspect ratio if required
      if (requireSquare && !_isSquareImage(image.width, image.height)) {
        return 'Image must be square (1:1 aspect ratio)';
      }
      
      // Check if image has reasonable content (not solid color, not corrupted)
      final contentValidation = _validateImageContent(image);
      if (contentValidation != null) {
        return contentValidation;
      }
      
      // Performance check - warn about very large images
      if (image.width * image.height > 2000 * 2000) {
        // This is a warning, not an error - we allow it but suggest optimization
        // Could be returned as metadata rather than blocking validation
      }
      
      return null; // Valid image
      
    } catch (e) {
      return 'Could not process image: ${e.toString()}';
    }
  }
  
  /// Validate image dimensions
  static String? _validateDimensions(
    int width, 
    int height, {
    bool isProfilePicture = false,
    bool requireSquare = false,
  }) {
    if (isProfilePicture) {
      // Profile picture specific validation
      if (width < profileMinSize || height < profileMinSize) {
        return 'Profile picture must be at least ${profileMinSize}x$profileMinSize pixels';
      }
      
      if (width > profileMaxSize || height > profileMaxSize) {
        return 'Profile picture must not exceed ${profileMaxSize}x$profileMaxSize pixels';
      }
    } else {
      // General image validation
      if (width < minWidth || height < minHeight) {
        return 'Image must be at least ${minWidth}x$minHeight pixels';
      }
      
      if (width > maxWidth || height > maxHeight) {
        return 'Image must not exceed ${maxWidth}x$maxWidth pixels';
      }
    }
    
    return null;
  }
  
  /// Check if image has valid file signature
  static bool _hasValidImageSignature(Uint8List bytes) {
    if (bytes.length < 4) return false;
    
    // Check common image file signatures
    // JPEG: FF D8 FF
    if (bytes[0] == 0xFF && bytes[1] == 0xD8 && bytes[2] == 0xFF) {
      return true;
    }
    
    // PNG: 89 50 4E 47
    if (bytes[0] == 0x89 && bytes[1] == 0x50 && bytes[2] == 0x4E && bytes[3] == 0x47) {
      return true;
    }
    
    // WebP: RIFF + WEBP
    if (bytes.length >= 12 &&
        bytes[0] == 0x52 && bytes[1] == 0x49 && bytes[2] == 0x46 && bytes[3] == 0x46 &&
        bytes[8] == 0x57 && bytes[9] == 0x45 && bytes[10] == 0x42 && bytes[11] == 0x50) {
      return true;
    }
    
    return false;
  }
  
  /// Validate image content quality
  static String? _validateImageContent(img.Image image) {
    // Check if image is completely transparent
    bool hasOpaquePixels = false;
    int colorVariation = 0;
    int? firstColor;
    
    // Sample pixels to check content quality
    final sampleSize = (image.width * image.height / 100).round().clamp(100, 1000);
    
    for (int i = 0; i < sampleSize; i++) {
      final x = (i * image.width / sampleSize).floor() % image.width;
      final y = (i * image.height / sampleSize).floor() % image.height;
      
      final pixel = image.getPixel(x, y);
      final alpha = img.getAlpha(pixel);
      
      if (alpha > 128) { // Semi-opaque or opaque
        hasOpaquePixels = true;
      }
      
      // Check color variation (simplified)
      final colorValue = img.getRed(pixel) + img.getGreen(pixel) + img.getBlue(pixel);
      
      if (firstColor == null) {
        firstColor = colorValue;
      } else if ((colorValue - firstColor).abs() > 30) {
        colorVariation++;
      }
    }
    
    if (!hasOpaquePixels) {
      return 'Image appears to be completely transparent';
    }
    
    // Check if image is solid color (very low variation)
    if (colorVariation < sampleSize * 0.1) {
      return 'Image appears to be solid color or corrupted';
    }
    
    return null;
  }
  
  /// Check if image is square
  static bool _isSquareImage(int width, int height) {
    return width == height;
  }
  
  /// Check if aspect ratio is valid
  static bool isValidAspectRatio(int width, int height, {double tolerance = 0.1}) {
    final ratio = width / height;
    return ratio >= (0.5 - tolerance) && ratio <= (2.0 + tolerance); // Between 1:2 and 2:1
  }
  
  /// Get aspect ratio as readable string
  static String getAspectRatioString(int width, int height) {
    final ratio = width / height;
    
    if ((ratio - 1.0).abs() < 0.05) return '1:1';
    if ((ratio - 1.33).abs() < 0.05) return '4:3';
    if ((ratio - 1.78).abs() < 0.05) return '16:9';
    if ((ratio - 0.75).abs() < 0.05) return '3:4';
    if ((ratio - 0.56).abs() < 0.05) return '9:16';
    
    return '$width:$height';
  }
  
  /// Validate image URL
  static String? validateImageUrl(String? url) {
    if (url == null || url.isEmpty) {
      return null; // Optional field
    }
    
    final trimmed = url.trim();
    
    // Check if it's a valid URL
    final uri = Uri.tryParse(trimmed);
    if (uri == null || !uri.hasAbsolutePath) {
      return 'Invalid image URL format';
    }
    
    // Must be HTTP or HTTPS
    if (uri.scheme != 'http' && uri.scheme != 'https') {
      return 'Image URL must use HTTP or HTTPS protocol';
    }
    
    // Check file extension if present
    final pathSegments = uri.pathSegments;
    if (pathSegments.isNotEmpty) {
      final lastSegment = pathSegments.last.toLowerCase();
      final extension = path.extension(lastSegment).substring(1);
      
      if (extension.isNotEmpty && !allowedFormats.contains(extension)) {
        return 'URL must point to ${allowedFormats.map((f) => f.toUpperCase()).join(', ')} image';
      }
    }
    
    // URL length check
    if (trimmed.length > 2048) {
      return 'Image URL is too long';
    }
    
    // Check for suspicious patterns
    if (trimmed.contains('..') || trimmed.contains('localhost')) {
      return 'Invalid image URL';
    }
    
    return null;
  }
  
  /// Validate multiple image files at once
  static Future<Map<String, String?>> validateImageFiles(
    List<File> files, {
    bool isProfilePicture = false,
    int? maxFiles,
  }) async {
    final results = <String, String?>{};
    
    if (maxFiles != null && files.length > maxFiles) {
      results['general'] = 'Cannot upload more than $maxFiles images';
      return results;
    }
    
    for (int i = 0; i < files.length; i++) {
      final file = files[i];
      final key = 'file_$i';
      
      try {
        results[key] = await validateImageFile(
          file, 
          isProfilePicture: isProfilePicture,
        );
      } catch (e) {
        results[key] = 'Error validating ${file.path}: ${e.toString()}';
      }
    }
    
    return results;
  }
  
  /// Get image format recommendation based on use case
  static String getRecommendedFormat(String useCase) {
    switch (useCase.toLowerCase()) {
      case 'profile_picture':
      case 'avatar':
        return 'webp'; // Best compression for profile pics
      case 'photo':
      case 'gallery':
        return 'jpg'; // Standard for photos
      case 'logo':
      case 'icon':
        return 'png'; // Transparency support
      default:
        return 'jpg';
    }
  }
  
  /// Get recommended dimensions for use case
  static Map<String, int> getRecommendedDimensions(String useCase) {
    switch (useCase.toLowerCase()) {
      case 'profile_picture':
      case 'avatar':
        return {'width': profileRecommendedSize, 'height': profileRecommendedSize};
      case 'cover_photo':
        return {'width': 1200, 'height': 400};
      case 'thumbnail':
        return {'width': 300, 'height': 300};
      case 'gallery':
        return {'width': 800, 'height': 600};
      default:
        return {'width': 500, 'height': 500};
    }
  }
  
  /// Check if image needs optimization
  static Future<Map<String, dynamic>> analyzeImageOptimization(File file) async {
    final analysis = <String, dynamic>{};
    
    try {
      final size = await file.length();
      final bytes = await file.readAsBytes();
      final image = img.decodeImage(bytes);
      
      if (image == null) {
        analysis['error'] = 'Could not decode image';
        return analysis;
      }
      
      analysis['current_size_bytes'] = size;
      analysis['current_size_mb'] = (size / (1024 * 1024)).toStringAsFixed(2);
      analysis['current_dimensions'] = '${image.width}x${image.height}';
      analysis['current_format'] = path.extension(file.path).substring(1).toLowerCase();
      
      // Size optimization recommendations
      if (size > maxProfileImageSize) {
        analysis['size_optimization'] = 'Consider compressing image to reduce file size';
      }
      
      // Dimension optimization recommendations  
      final pixelCount = image.width * image.height;
      if (pixelCount > 1000000) { // 1MP
        analysis['dimension_optimization'] = 'Consider reducing image dimensions';
        analysis['recommended_dimensions'] = '${(image.width * 0.7).round()}x${(image.height * 0.7).round()}';
      }
      
      // Format optimization recommendations
      final currentFormat = path.extension(file.path).substring(1).toLowerCase();
      if (currentFormat == 'png' && !_imageNeedsTransparency(image)) {
        analysis['format_optimization'] = 'Consider using JPEG for better compression';
        analysis['recommended_format'] = 'jpg';
      }
      
      // Estimated optimized size
      double estimatedReduction = 0.0;
      if (currentFormat == 'png') estimatedReduction += 0.3;
      if (pixelCount > 1000000) estimatedReduction += 0.4;
      
      if (estimatedReduction > 0) {
        final estimatedSize = size * (1 - estimatedReduction);
        analysis['estimated_optimized_size'] = '${(estimatedSize / (1024 * 1024)).toStringAsFixed(2)}MB';
        analysis['estimated_savings'] = '${(estimatedReduction * 100).round()}%';
      }
      
    } catch (e) {
      analysis['error'] = e.toString();
    }
    
    return analysis;
  }
  
  /// Check if image needs transparency (PNG vs JPEG decision)
  static bool _imageNeedsTransparency(img.Image image) {
    // Sample pixels to check for transparency
    for (int y = 0; y < image.height; y += 10) {
      for (int x = 0; x < image.width; x += 10) {
        final pixel = image.getPixel(x, y);
        final alpha = img.getAlpha(pixel);
        if (alpha < 255) {
          return true; // Has transparency
        }
      }
    }
    return false;
  }
  
  /// Generate comprehensive validation report
  static Future<Map<String, dynamic>> generateValidationReport(File file) async {
    final report = <String, dynamic>{};
    
    try {
      // Basic file info
      report['filename'] = path.basename(file.path);
      report['file_size'] = await file.length();
      report['extension'] = path.extension(file.path).substring(1).toLowerCase();
      
      // Validation results
      report['is_valid'] = await validateImageFile(file) == null;
      report['validation_errors'] = await validateImageFile(file);
      
      // Image analysis
      final bytes = await file.readAsBytes();
      final image = img.decodeImage(bytes);
      
      if (image != null) {
        report['dimensions'] = {
          'width': image.width,
          'height': image.height,
          'aspect_ratio': getAspectRatioString(image.width, image.height),
          'is_square': _isSquareImage(image.width, image.height),
          'total_pixels': image.width * image.height,
        };
        
        report['format_info'] = {
          'current_format': report['extension'],
          'recommended_format': getRecommendedFormat('photo'),
          'supports_transparency': _imageNeedsTransparency(image),
        };
        
        // Optimization analysis
        report['optimization'] = await analyzeImageOptimization(file);
      }
      
      report['timestamp'] = DateTime.now().toIso8601String();
      
    } catch (e) {
      report['error'] = e.toString();
    }
    
    return report;
  }
}
