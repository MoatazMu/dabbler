import 'package:dartz/dartz.dart';
import '../../../../core/error/failures.dart';
import '../../domain/entities/activity_log.dart';
import '../../domain/repositories/activity_log_repository.dart';
import '../datasources/activity_log_remote_data_source.dart';
import '../models/activity_log_model.dart';

/// Implementation of ActivityLogRepository
class ActivityLogRepositoryImpl implements ActivityLogRepository {
  final ActivityLogRemoteDataSource remoteDataSource;

  ActivityLogRepositoryImpl({required this.remoteDataSource});

  @override
  Future<Either<Failure, List<ActivityLog>>> getUserActivities({
    required String userId,
    ActivityType? type,
    String? category,
    DateTime? startDate,
    DateTime? endDate,
    int page = 1,
    int limit = 50,
  }) async {
    try {
      final activities = await remoteDataSource.getUserActivities(
        userId: userId,
        type: type,
        category: category,
        startDate: startDate,
        endDate: endDate,
        page: page,
        limit: limit,
      );

      return Right(activities);
    } catch (e) {
      return Left(ServerFailure(message: e.toString()));
    }
  }

  @override
  Future<Either<Failure, Map<String, int>>> getUserActivityStats({
    required String userId,
    DateTime? startDate,
    DateTime? endDate,
  }) async {
    try {
      final stats = await remoteDataSource.getUserActivityStats(
        userId: userId,
        startDate: startDate,
        endDate: endDate,
      );

      return Right(stats);
    } catch (e) {
      return Left(ServerFailure(message: e.toString()));
    }
  }

  @override
  Future<Either<Failure, ActivityLog>> createActivity({
    required String userId,
    required ActivityType type,
    String? subType,
    required String title,
    String? description,
    ActivityStatus? status,
    String? targetId,
    String? targetType,
    String? targetUserId,
    String? targetUserName,
    String? targetUserAvatar,
    String? venue,
    String? location,
    double? amount,
    String? currency,
    int? points,
    int? count,
    DateTime? scheduledDate,
    Map<String, dynamic>? metadata,
    String? iconUrl,
    String? thumbnailUrl,
    String? actionRoute,
  }) async {
    try {
      final activity = ActivityLogModel(
        id: '', // Will be generated by database
        userId: userId,
        type: type,
        subType: subType,
        title: title,
        description: description,
        status: status ?? ActivityStatus.completed,
        targetId: targetId,
        targetType: targetType,
        targetUserId: targetUserId,
        targetUserName: targetUserName,
        targetUserAvatar: targetUserAvatar,
        venue: venue,
        location: location,
        amount: amount,
        currency: currency,
        points: points,
        count: count,
        createdAt: DateTime.now(),
        scheduledDate: scheduledDate,
        metadata: metadata,
        iconUrl: iconUrl,
        thumbnailUrl: thumbnailUrl,
        actionRoute: actionRoute,
      );

      final result = await remoteDataSource.createActivity(activity);
      return Right(result);
    } catch (e) {
      return Left(ServerFailure(message: e.toString()));
    }
  }

  @override
  Future<Either<Failure, ActivityLog>> updateActivity({
    required String activityId,
    ActivityStatus? status,
    String? description,
    Map<String, dynamic>? metadata,
  }) async {
    try {
      final result = await remoteDataSource.updateActivity(
        activityId: activityId,
        status: status,
        description: description,
        metadata: metadata,
      );

      return Right(result);
    } catch (e) {
      return Left(ServerFailure(message: e.toString()));
    }
  }

  @override
  Future<Either<Failure, bool>> deleteActivity(String activityId) async {
    try {
      final result = await remoteDataSource.deleteActivity(activityId);
      return Right(result);
    } catch (e) {
      return Left(ServerFailure(message: e.toString()));
    }
  }

  @override
  Future<Either<Failure, Map<String, List<ActivityLog>>>> getActivitiesByDateRange({
    required String userId,
    required DateTime startDate,
    required DateTime endDate,
  }) async {
    try {
      final activities = await remoteDataSource.getUserActivities(
        userId: userId,
        startDate: startDate,
        endDate: endDate,
        limit: 1000,
      );

      final Map<String, List<ActivityLog>> grouped = {
        'Today': [],
        'Yesterday': [],
        'This Week': [],
        'This Month': [],
        'Older': [],
      };

      for (final activity in activities) {
        grouped[activity.formattedDate]?.add(activity);
      }

      return Right(grouped);
    } catch (e) {
      return Left(ServerFailure(message: e.toString()));
    }
  }

  @override
  Future<Either<Failure, List<ActivityLog>>> getRecentActivities({
    required String userId,
    int days = 7,
  }) async {
    try {
      final startDate = DateTime.now().subtract(Duration(days: days));
      final activities = await remoteDataSource.getUserActivities(
        userId: userId,
        startDate: startDate,
        limit: 100,
      );

      return Right(activities);
    } catch (e) {
      return Left(ServerFailure(message: e.toString()));
    }
  }

  @override
  Future<Either<Failure, Map<String, int>>> getCategoryStats(String userId) async {
    try {
      final stats = await remoteDataSource.getCategoryStats(userId);
      return Right(stats);
    } catch (e) {
      return Left(ServerFailure(message: e.toString()));
    }
  }
}
