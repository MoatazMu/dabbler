import 'dart:async';
import 'dart:convert';
import 'package:flutter/foundation.dart';
import 'package:share_plus/share_plus.dart';
import 'package:url_launcher/url_launcher.dart';
import '../../../core/utils/either.dart';
import '../../../core/services/analytics_service.dart';
import '../../../core/services/storage_service.dart';
import '../data/models/post_model.dart';
import '../data/models/user_model.dart';

/// Service for handling content sharing and deep links
class ContentSharingService {
  final AnalyticsService _analyticsService;
  final StorageService _storageService;

  // Share templates and configurations
  final Map<String, ShareTemplate> _shareTemplates = {};
  final Map<String, int> _shareAnalytics = {};

  // Deep link configuration
  String? _baseUrl;
  String? _appScheme;
  
  // Social media configurations
  final Map<String, SocialPlatformConfig> _socialConfigs = {};

  ContentSharingService({
    required AnalyticsService analyticsService,
    required StorageService storageService,
  })  : _analyticsService = analyticsService,
        _storageService = storageService {
    _initializeService();
  }

  void _initializeService() {
    _loadShareConfiguration();
    _setupShareTemplates();
    _setupSocialConfigs();
  }

  /// Generate shareable link for a post
  Future<Either<String, String>> generateShareableLink({
    required String postId,
    String? customMessage,
    Map<String, dynamic>? metadata,
  }) async {
    try {
      if (_baseUrl == null) {
        return Left('Base URL not configured');
      }

      // Generate link with tracking parameters
      final shareId = _generateShareId();
      final link = '$_baseUrl/post/$postId?share_id=$shareId&utm_source=app_share';

      // Store share metadata for analytics
      await _storageService.storeShareMetadata(shareId, {
        'post_id': postId,
        'custom_message': customMessage,
        'metadata': metadata ?? {},
        'created_at': DateTime.now().toIso8601String(),
        'share_type': 'post',
      });

      // Track analytics
      _analyticsService.trackEvent('shareable_link_generated', {
        'post_id': postId,
        'share_id': shareId,
        'has_custom_message': customMessage != null,
      });

      return Right(link);
    } catch (e) {
      debugPrint('Error generating shareable link: $e');
      return Left('Failed to generate shareable link: ${e.toString()}');
    }
  }

  /// Generate shareable link for user profile
  Future<Either<String, String>> generateProfileShareableLink({
    required String userId,
    String? customMessage,
  }) async {
    try {
      if (_baseUrl == null) {
        return Left('Base URL not configured');
      }

      final shareId = _generateShareId();
      final link = '$_baseUrl/profile/$userId?share_id=$shareId&utm_source=app_share';

      // Store share metadata
      await _storageService.storeShareMetadata(shareId, {
        'user_id': userId,
        'custom_message': customMessage,
        'created_at': DateTime.now().toIso8601String(),
        'share_type': 'profile',
      });

      _analyticsService.trackEvent('profile_link_generated', {
        'user_id': userId,
        'share_id': shareId,
      });

      return Right(link);
    } catch (e) {
      debugPrint('Error generating profile link: $e');
      return Left('Failed to generate profile link: ${e.toString()}');
    }
  }

  /// Create preview card data for sharing
  Future<Either<String, Map<String, dynamic>>> createPreviewCard({
    required String postId,
    PostModel? post,
  }) async {
    try {
      // Get post data if not provided
      PostModel? postData = post;
      if (postData == null) {
        // In a real implementation, you'd fetch the post from repository
        return Left('Post data not available');
      }

      // Generate preview image URL
      String? previewImageUrl;
      if (postData.mediaUrls.isNotEmpty) {
        previewImageUrl = postData.mediaUrls.first;
      } else {
        // Generate a default preview image
        previewImageUrl = await _generateDefaultPreviewImage(postData);
      }

      final previewCard = {
        'title': '${postData.authorName} on Dabbler',
        'description': _truncateText(postData.content, 160),
        'image_url': previewImageUrl,
        'url': '$_baseUrl/post/$postId',
        'site_name': 'Dabbler',
        'type': 'article',
        'author': postData.authorName,
        'published_time': postData.createdAt.toIso8601String(),
      };

      return Right(previewCard);
    } catch (e) {
      debugPrint('Error creating preview card: $e');
      return Left('Failed to create preview card: ${e.toString()}');
    }
  }

  /// Share content using native share sheet
  Future<Either<String, bool>> shareContent({
    required String content,
    List<String>? files,
    String? subject,
    Map<String, dynamic>? metadata,
  }) async {
    try {
      final shareResult = await Share.shareWithResult(
        content,
        subject: subject,
        files: files?.map((path) => XFile(path)).toList(),
      );

      // Track share analytics
      await _trackShareResult(shareResult, metadata);

      if (shareResult.status == ShareResultStatus.success) {
        return Right(true);
      } else {
        return Left('Share was cancelled or failed');
      }
    } catch (e) {
      debugPrint('Error sharing content: $e');
      return Left('Failed to share content: ${e.toString()}');
    }
  }

  /// Share to specific social media platform
  Future<Either<String, bool>> shareToSocialMedia({
    required String platform,
    required String content,
    String? imageUrl,
    String? linkUrl,
  }) async {
    try {
      final config = _socialConfigs[platform];
      if (config == null) {
        return Left('Unsupported platform: $platform');
      }

      final shareUrl = _buildSocialShareUrl(
        config: config,
        content: content,
        imageUrl: imageUrl,
        linkUrl: linkUrl,
      );

      final uri = Uri.parse(shareUrl);
      final canLaunch = await canLaunchUrl(uri);

      if (!canLaunch) {
        return Left('Cannot launch $platform app/website');
      }

      await launchUrl(uri, mode: LaunchMode.externalApplication);

      // Track analytics
      _analyticsService.trackEvent('social_media_share', {
        'platform': platform,
        'has_image': imageUrl != null,
        'has_link': linkUrl != null,
      });

      return Right(true);
    } catch (e) {
      debugPrint('Error sharing to social media: $e');
      return Left('Failed to share to $platform: ${e.toString()}');
    }
  }

  /// Handle incoming deep link
  Future<Either<String, Map<String, dynamic>>> handleDeepLink({
    required String link,
  }) async {
    try {
      final uri = Uri.parse(link);
      
      // Extract path and parameters
      final pathSegments = uri.pathSegments;
      final queryParameters = uri.queryParameters;

      if (pathSegments.isEmpty) {
        return Left('Invalid deep link format');
      }

      // Route based on path
      final routeType = pathSegments.first;
      
      Map<String, dynamic> routeData = {
        'route_type': routeType,
        'parameters': queryParameters,
      };

      switch (routeType) {
        case 'post':
          if (pathSegments.length < 2) {
            return Left('Missing post ID in deep link');
          }
          routeData['post_id'] = pathSegments[1];
          break;
          
        case 'profile':
          if (pathSegments.length < 2) {
            return Left('Missing user ID in deep link');
          }
          routeData['user_id'] = pathSegments[1];
          break;
          
        case 'chat':
          if (pathSegments.length >= 2) {
            routeData['conversation_id'] = pathSegments[1];
          }
          break;
          
        default:
          return Left('Unknown deep link route: $routeType');
      }

      // Track analytics for deep link
      final shareId = queryParameters['share_id'];
      await _trackDeepLinkOpen(link, shareId);

      return Right(routeData);
    } catch (e) {
      debugPrint('Error handling deep link: $e');
      return Left('Failed to handle deep link: ${e.toString()}');
    }
  }

  /// Get share analytics for a post
  Future<Either<String, Map<String, dynamic>>> getShareAnalytics({
    required String postId,
  }) async {
    try {
      final analytics = await _storageService.getShareAnalytics(postId);
      
      return Right({
        'total_shares': analytics['total_shares'] ?? 0,
        'platform_breakdown': analytics['platform_breakdown'] ?? {},
        'share_timeline': analytics['share_timeline'] ?? [],
        'click_through_rate': analytics['click_through_rate'] ?? 0.0,
        'top_referrers': analytics['top_referrers'] ?? [],
      });
    } catch (e) {
      debugPrint('Error getting share analytics: $e');
      return Left('Failed to get share analytics: ${e.toString()}');
    }
  }

  /// Create custom share message based on template
  String createCustomShareMessage({
    required String templateKey,
    required Map<String, dynamic> variables,
  }) {
    final template = _shareTemplates[templateKey];
    if (template == null) {
      return variables['default_message'] ?? 'Check this out on Dabbler!';
    }

    String message = template.template;
    
    for (final entry in variables.entries) {
      message = message.replaceAll('{{${entry.key}}}', entry.value.toString());
    }

    return message;
  }

  /// Generate QR code for sharing
  Future<Either<String, String>> generateQRCode({
    required String content,
    int size = 200,
  }) async {
    try {
      // In a real implementation, you'd use a QR code generation library
      // For now, return a URL to a QR code service
      final encodedContent = Uri.encodeComponent(content);
      final qrUrl = 'https://api.qrserver.com/v1/create-qr-code/?size=${size}x$size&data=$encodedContent';
      
      _analyticsService.trackEvent('qr_code_generated', {
        'content_type': content.startsWith('http') ? 'url' : 'text',
        'size': size,
      });

      return Right(qrUrl);
    } catch (e) {
      debugPrint('Error generating QR code: $e');
      return Left('Failed to generate QR code: ${e.toString()}');
    }
  }

  /// Get available share options
  List<ShareOption> getShareOptions({
    required String contentType,
  }) {
    final baseOptions = [
      ShareOption(
        id: 'native',
        name: 'More Options',
        icon: 'share',
        isNative: true,
      ),
      ShareOption(
        id: 'copy_link',
        name: 'Copy Link',
        icon: 'copy',
        isNative: false,
      ),
    ];

    // Add social media options
    for (final entry in _socialConfigs.entries) {
      baseOptions.add(ShareOption(
        id: entry.key,
        name: entry.value.name,
        icon: entry.value.icon,
        isNative: false,
      ));
    }

    // Add QR code option for supported content
    if (contentType == 'post' || contentType == 'profile') {
      baseOptions.add(ShareOption(
        id: 'qr_code',
        name: 'QR Code',
        icon: 'qr_code',
        isNative: false,
      ));
    }

    return baseOptions;
  }

  void _loadShareConfiguration() {
    // Load configuration from storage or environment
    _baseUrl = 'https://dabbler.app'; // Replace with actual base URL
    _appScheme = 'dabbler';
  }

  void _setupShareTemplates() {
    _shareTemplates['post_share'] = ShareTemplate(
      id: 'post_share',
      template: 'Check out this post by {{author_name}} on Dabbler! {{post_content}} {{share_link}}',
      variables: ['author_name', 'post_content', 'share_link'],
    );

    _shareTemplates['profile_share'] = ShareTemplate(
      id: 'profile_share',
      template: 'Follow {{user_name}} on Dabbler! {{profile_link}}',
      variables: ['user_name', 'profile_link'],
    );

    _shareTemplates['achievement_share'] = ShareTemplate(
      id: 'achievement_share',
      template: 'I just {{achievement}} on Dabbler! Join me at {{app_link}}',
      variables: ['achievement', 'app_link'],
    );
  }

  void _setupSocialConfigs() {
    _socialConfigs['twitter'] = SocialPlatformConfig(
      id: 'twitter',
      name: 'Twitter',
      icon: 'twitter',
      urlTemplate: 'https://twitter.com/intent/tweet?text={{content}}&url={{url}}',
      maxContentLength: 280,
    );

    _socialConfigs['facebook'] = SocialPlatformConfig(
      id: 'facebook',
      name: 'Facebook',
      icon: 'facebook',
      urlTemplate: 'https://www.facebook.com/sharer/sharer.php?u={{url}}&quote={{content}}',
      maxContentLength: 500,
    );

    _socialConfigs['instagram'] = SocialPlatformConfig(
      id: 'instagram',
      name: 'Instagram Stories',
      icon: 'instagram',
      urlTemplate: 'instagram-stories://share?source_application={{app_id}}',
      maxContentLength: 2200,
    );

    _socialConfigs['whatsapp'] = SocialPlatformConfig(
      id: 'whatsapp',
      name: 'WhatsApp',
      icon: 'whatsapp',
      urlTemplate: 'whatsapp://send?text={{content}}%20{{url}}',
      maxContentLength: 1000,
    );

    _socialConfigs['telegram'] = SocialPlatformConfig(
      id: 'telegram',
      name: 'Telegram',
      icon: 'telegram',
      urlTemplate: 'https://telegram.me/share/url?url={{url}}&text={{content}}',
      maxContentLength: 1000,
    );
  }

  String _buildSocialShareUrl({
    required SocialPlatformConfig config,
    required String content,
    String? imageUrl,
    String? linkUrl,
  }) {
    String shareUrl = config.urlTemplate;
    
    // Truncate content if necessary
    String truncatedContent = content;
    if (content.length > config.maxContentLength) {
      truncatedContent = '${content.substring(0, config.maxContentLength - 3)}...';
    }
    
    // Replace template variables
    shareUrl = shareUrl.replaceAll('{{content}}', Uri.encodeComponent(truncatedContent));
    shareUrl = shareUrl.replaceAll('{{url}}', Uri.encodeComponent(linkUrl ?? ''));
    
    if (imageUrl != null) {
      shareUrl = shareUrl.replaceAll('{{image}}', Uri.encodeComponent(imageUrl));
    }
    
    return shareUrl;
  }

  Future<String?> _generateDefaultPreviewImage(PostModel post) async {
    try {
      // Generate a preview image with post content and author info
      // This would typically be done server-side or using a service
      final previewData = {
        'content': _truncateText(post.content, 100),
        'author': post.authorName,
        'timestamp': post.createdAt.toIso8601String(),
      };

      // Return a URL to a generated preview image
      final encodedData = base64Encode(utf8.encode(jsonEncode(previewData)));
      return 'https://api.dabbler.app/generate-preview?data=$encodedData';
    } catch (e) {
      debugPrint('Error generating default preview image: $e');
      return null;
    }
  }

  Future<void> _trackShareResult(
    ShareResult result,
    Map<String, dynamic>? metadata,
  ) async {
    _analyticsService.trackEvent('content_shared', {
      'status': result.status.toString(),
      'raw': result.raw,
      'metadata': metadata ?? {},
    });

    // Update share counter
    final shareType = metadata?['share_type'] ?? 'unknown';
    _shareAnalytics[shareType] = (_shareAnalytics[shareType] ?? 0) + 1;
  }

  Future<void> _trackDeepLinkOpen(String link, String? shareId) async {
    _analyticsService.trackEvent('deep_link_opened', {
      'link': link,
      'share_id': shareId,
      'timestamp': DateTime.now().toIso8601String(),
    });

    // If this is from a share, update click-through analytics
    if (shareId != null) {
      await _storageService.incrementShareClickThrough(shareId);
    }
  }

  String _generateShareId() {
    return 'share_${DateTime.now().millisecondsSinceEpoch}_${_generateRandomString(6)}';
  }

  String _generateRandomString(int length) {
    const chars = 'abcdefghijklmnopqrstuvwxyz0123456789';
    return List.generate(length, (index) => 
        chars[(DateTime.now().millisecondsSinceEpoch + index) % chars.length]).join();
  }

  String _truncateText(String text, int maxLength) {
    if (text.length <= maxLength) return text;
    return '${text.substring(0, maxLength)}...';
  }

  /// Get share statistics
  Map<String, dynamic> getShareStats() {
    return {
      'total_shares_by_type': Map<String, int>.from(_shareAnalytics),
      'available_platforms': _socialConfigs.keys.toList(),
      'share_templates': _shareTemplates.keys.toList(),
    };
  }

  /// Dispose service and cleanup
  void dispose() {
    _shareTemplates.clear();
    _socialConfigs.clear();
    _shareAnalytics.clear();
  }
}

class ShareTemplate {
  final String id;
  final String template;
  final List<String> variables;

  ShareTemplate({
    required this.id,
    required this.template,
    required this.variables,
  });
}

class SocialPlatformConfig {
  final String id;
  final String name;
  final String icon;
  final String urlTemplate;
  final int maxContentLength;

  SocialPlatformConfig({
    required this.id,
    required this.name,
    required this.icon,
    required this.urlTemplate,
    required this.maxContentLength,
  });
}

class ShareOption {
  final String id;
  final String name;
  final String icon;
  final bool isNative;

  ShareOption({
    required this.id,
    required this.name,
    required this.icon,
    required this.isNative,
  });
}
