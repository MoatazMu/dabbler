import '../../../core/analytics/analytics_service.dart';
import '../../../core/services/storage_service.dart';
import '../services/social_analytics_service.dart';
import '../services/social_health_monitoring_service.dart';
import '../services/social_performance_monitoring_service.dart';
import '../services/social_error_tracking_service.dart';
import '../services/social_abuse_detection_service.dart';
import '../services/social_monitoring_dashboard_service.dart';

/// Configuration class for social monitoring services
class SocialMonitoringConfig {
  // Health monitoring configuration
  final bool enableHealthMonitoring;
  final Duration healthCheckInterval;
  final Duration healthAggregationInterval;

  // Performance monitoring configuration
  final bool enablePerformanceMonitoring;
  final Duration performanceCheckInterval;
  final int maxPerformanceBufferSize;

  // Error tracking configuration
  final bool enableErrorTracking;
  final Duration errorProcessingInterval;
  final Duration errorRetentionPeriod;
  final int criticalErrorThreshold;

  // Abuse detection configuration
  final bool enableAbuseDetection;
  final Duration behaviorAnalysisInterval;
  final double spamThreshold;
  final double harassmentThreshold;
  final double botBehaviorThreshold;

  // Dashboard configuration
  final bool enableDashboard;
  final Duration dashboardUpdateInterval;
  final Duration dashboardCacheValidDuration;

  const SocialMonitoringConfig({
    // Health monitoring defaults
    this.enableHealthMonitoring = true,
    this.healthCheckInterval = const Duration(minutes: 5),
    this.healthAggregationInterval = const Duration(hours: 1),

    // Performance monitoring defaults
    this.enablePerformanceMonitoring = true,
    this.performanceCheckInterval = const Duration(minutes: 1),
    this.maxPerformanceBufferSize = 1000,

    // Error tracking defaults
    this.enableErrorTracking = true,
    this.errorProcessingInterval = const Duration(minutes: 5),
    this.errorRetentionPeriod = const Duration(days: 30),
    this.criticalErrorThreshold = 10,

    // Abuse detection defaults
    this.enableAbuseDetection = true,
    this.behaviorAnalysisInterval = const Duration(minutes: 10),
    this.spamThreshold = 0.7,
    this.harassmentThreshold = 0.8,
    this.botBehaviorThreshold = 0.75,

    // Dashboard defaults
    this.enableDashboard = true,
    this.dashboardUpdateInterval = const Duration(minutes: 5),
    this.dashboardCacheValidDuration = const Duration(minutes: 3),
  });

  /// Create a development configuration with more frequent updates
  factory SocialMonitoringConfig.development() {
    return const SocialMonitoringConfig(
      healthCheckInterval: Duration(minutes: 1),
      performanceCheckInterval: Duration(seconds: 30),
      errorProcessingInterval: Duration(minutes: 1),
      behaviorAnalysisInterval: Duration(minutes: 2),
      dashboardUpdateInterval: Duration(minutes: 1),
    );
  }

  /// Create a production configuration with optimized intervals
  factory SocialMonitoringConfig.production() {
    return const SocialMonitoringConfig(
      healthCheckInterval: Duration(minutes: 10),
      performanceCheckInterval: Duration(minutes: 5),
      errorProcessingInterval: Duration(minutes: 10),
      behaviorAnalysisInterval: Duration(minutes: 30),
      dashboardUpdateInterval: Duration(minutes: 10),
    );
  }
}

/// Provider class for social monitoring services
class SocialMonitoringProvider {
  static SocialMonitoringProvider? _instance;
  
  final SocialMonitoringConfig _config;
  final AnalyticsService _analytics;
  final StorageService _storage;
  
  // Core services
  late final SocialAnalyticsService _socialAnalytics;
  late final SocialHealthMonitoringService _healthMonitoring;
  late final SocialPerformanceMonitoringService _performanceMonitoring;
  late final SocialErrorTrackingService _errorTracking;
  late final SocialAbuseDetectionService _abuseDetection;
  late final SocialMonitoringDashboardService _dashboardService;
  
  // Helper utilities
  late final SocialMonitoringHelper _monitoringHelper;

  bool _isInitialized = false;

  SocialMonitoringProvider._({
    required SocialMonitoringConfig config,
    required AnalyticsService analytics,
    required StorageService storage,
  })  : _config = config,
        _analytics = analytics,
        _storage = storage;

  /// Initialize the social monitoring provider
  static Future<SocialMonitoringProvider> initialize({
    required AnalyticsService analytics,
    required StorageService storage,
    SocialMonitoringConfig? config,
  }) async {
    if (_instance != null) {
      return _instance!;
    }

    final provider = SocialMonitoringProvider._(
      config: config ?? const SocialMonitoringConfig(),
      analytics: analytics,
      storage: storage,
    );

    await provider._initializeServices();
    _instance = provider;
    
    return provider;
  }

  /// Get the singleton instance
  static SocialMonitoringProvider get instance {
    if (_instance == null) {
      throw StateError('SocialMonitoringProvider not initialized. Call initialize() first.');
    }
    return _instance!;
  }

  /// Initialize all monitoring services
  Future<void> _initializeServices() async {
    if (_isInitialized) return;

    try {
      // Initialize social analytics service (existing)
      _socialAnalytics = SocialAnalyticsService();

      // Initialize health monitoring service
      if (_config.enableHealthMonitoring) {
        _healthMonitoring = SocialHealthMonitoringService(
          analytics: _analytics,
          storage: _storage,
          socialAnalytics: _socialAnalytics,
        );
      }

      // Initialize performance monitoring service
      if (_config.enablePerformanceMonitoring) {
        _performanceMonitoring = SocialPerformanceMonitoringService(
          analytics: _analytics,
          storage: _storage,
        );
      }

      // Initialize error tracking service
      if (_config.enableErrorTracking) {
        _errorTracking = SocialErrorTrackingService(
          analytics: _analytics,
          storage: _storage,
        );
      }

      // Initialize abuse detection service
      if (_config.enableAbuseDetection) {
        _abuseDetection = SocialAbuseDetectionService(
          analytics: _analytics,
          storage: _storage,
        );
      }

      // Initialize dashboard service
      if (_config.enableDashboard) {
        _dashboardService = SocialMonitoringDashboardService(
          analytics: _analytics,
          storage: _storage,
          socialAnalytics: _socialAnalytics,
          healthMonitoring: _healthMonitoring,
          performanceMonitoring: _performanceMonitoring,
          errorTracking: _errorTracking,
          abuseDetection: _abuseDetection,
        );
      }

      // Initialize monitoring helper
      _monitoringHelper = SocialMonitoringHelper(
        healthMonitoring: _healthMonitoring,
        performanceMonitoring: _performanceMonitoring,
        errorTracking: _errorTracking,
        abuseDetection: _abuseDetection,
      );

      _isInitialized = true;
      
      // Track initialization
      await _analytics.trackEvent('social_monitoring_initialized', {
        'config': {
          'health_monitoring': _config.enableHealthMonitoring,
          'performance_monitoring': _config.enablePerformanceMonitoring,
          'error_tracking': _config.enableErrorTracking,
          'abuse_detection': _config.enableAbuseDetection,
          'dashboard': _config.enableDashboard,
        },
        'timestamp': DateTime.now().toIso8601String(),
      });

    } catch (e) {
      throw Exception('Failed to initialize social monitoring services: $e');
    }
  }

  // Service getters
  SocialAnalyticsService get socialAnalytics {
    _checkInitialized();
    return _socialAnalytics;
  }

  SocialHealthMonitoringService get healthMonitoring {
    _checkInitialized();
    if (!_config.enableHealthMonitoring) {
      throw StateError('Health monitoring is disabled in configuration');
    }
    return _healthMonitoring;
  }

  SocialPerformanceMonitoringService get performanceMonitoring {
    _checkInitialized();
    if (!_config.enablePerformanceMonitoring) {
      throw StateError('Performance monitoring is disabled in configuration');
    }
    return _performanceMonitoring;
  }

  SocialErrorTrackingService get errorTracking {
    _checkInitialized();
    if (!_config.enableErrorTracking) {
      throw StateError('Error tracking is disabled in configuration');
    }
    return _errorTracking;
  }

  SocialAbuseDetectionService get abuseDetection {
    _checkInitialized();
    if (!_config.enableAbuseDetection) {
      throw StateError('Abuse detection is disabled in configuration');
    }
    return _abuseDetection;
  }

  SocialMonitoringDashboardService get dashboardService {
    _checkInitialized();
    if (!_config.enableDashboard) {
      throw StateError('Dashboard service is disabled in configuration');
    }
    return _dashboardService;
  }

  SocialMonitoringHelper get monitoringHelper {
    _checkInitialized();
    return _monitoringHelper;
  }

  /// Get configuration
  SocialMonitoringConfig get config => _config;

  /// Check if services are initialized
  bool get isInitialized => _isInitialized;

  /// Check if a specific service is enabled
  bool isServiceEnabled(String serviceName) {
    switch (serviceName) {
      case 'health':
        return _config.enableHealthMonitoring;
      case 'performance':
        return _config.enablePerformanceMonitoring;
      case 'error':
        return _config.enableErrorTracking;
      case 'abuse':
        return _config.enableAbuseDetection;
      case 'dashboard':
        return _config.enableDashboard;
      default:
        return false;
    }
  }

  /// Get service health status
  Map<String, dynamic> getServiceHealthStatus() {
    _checkInitialized();
    
    return {
      'initialized': _isInitialized,
      'services': {
        'social_analytics': true,
        'health_monitoring': _config.enableHealthMonitoring,
        'performance_monitoring': _config.enablePerformanceMonitoring,
        'error_tracking': _config.enableErrorTracking,
        'abuse_detection': _config.enableAbuseDetection,
        'dashboard': _config.enableDashboard,
      },
      'timestamp': DateTime.now().toIso8601String(),
    };
  }

  /// Shutdown all monitoring services
  Future<void> shutdown() async {
    if (!_isInitialized) return;

    try {
      // Dispose all services in reverse order
      if (_config.enableDashboard) {
        _dashboardService.dispose();
      }
      
      if (_config.enableAbuseDetection) {
        _abuseDetection.dispose();
      }
      
      if (_config.enableErrorTracking) {
        _errorTracking.dispose();
      }
      
      if (_config.enablePerformanceMonitoring) {
        _performanceMonitoring.dispose();
      }
      
      if (_config.enableHealthMonitoring) {
        _healthMonitoring.dispose();
      }

      // Track shutdown
      await _analytics.trackEvent('social_monitoring_shutdown', {
        'timestamp': DateTime.now().toIso8601String(),
      });

      _isInitialized = false;
      _instance = null;

    } catch (e) {
      print('Error during social monitoring shutdown: $e');
    }
  }

  void _checkInitialized() {
    if (!_isInitialized) {
      throw StateError('SocialMonitoringProvider services not initialized');
    }
  }
}

/// Extension methods for easy integration with existing code
extension SocialMonitoringExtensions on Object {
  /// Get the monitoring provider instance
  SocialMonitoringProvider get monitoring => SocialMonitoringProvider.instance;

  /// Quick access to monitoring helper
  SocialMonitoringHelper get monitoringHelper => monitoring.monitoringHelper;
}

/// Utility class for common monitoring operations
class SocialMonitoringUtils {
  static final SocialMonitoringProvider _provider = SocialMonitoringProvider.instance;

  /// Quick method to track a social operation
  static Future<T> trackOperation<T>(
    String feature,
    String operation,
    Future<T> Function() operationFunc, {
    required String userId,
    String? content,
    Map<String, dynamic>? metadata,
  }) async {
    return await _provider.monitoringHelper._trackOperation(
      operationFunc,
      feature: feature,
      operation: operation,
      userId: userId,
      content: content,
      metadata: metadata,
    );
  }

  /// Quick method to track user action
  static void trackUserAction({
    required String userId,
    required String action,
    required String targetType,
    String? targetId,
    String? content,
    Map<String, dynamic>? metadata,
  }) {
    _provider.monitoringHelper.trackUserAction(
      userId: userId,
      action: action,
      targetType: targetType,
      targetId: targetId,
      content: content,
      metadata: metadata,
    );
  }

  /// Quick method to track error
  static void trackError({
    required String feature,
    required String operation,
    required String errorType,
    required String errorMessage,
    String? stackTrace,
    Map<String, dynamic>? context,
    String? userId,
    ErrorSeverity severity = ErrorSeverity.medium,
  }) {
    _provider.errorTracking.trackError(
      feature: feature,
      operation: operation,
      errorType: errorType,
      errorMessage: errorMessage,
      stackTrace: stackTrace,
      context: context,
      userId: userId,
      severity: severity,
    );
  }

  /// Check if monitoring is available
  static bool get isAvailable {
    try {
      return SocialMonitoringProvider.instance.isInitialized;
    } catch (e) {
      return false;
    }
  }
}

/// Constants for service configuration
class MonitoringServiceConstants {
  // Service names
  static const String serviceHealth = 'health';
  static const String servicePerformance = 'performance';
  static const String serviceError = 'error';
  static const String serviceAbuse = 'abuse';
  static const String serviceDashboard = 'dashboard';

  // Default intervals (in minutes)
  static const int defaultHealthCheckInterval = 5;
  static const int defaultPerformanceCheckInterval = 1;
  static const int defaultErrorProcessingInterval = 5;
  static const int defaultBehaviorAnalysisInterval = 10;
  static const int defaultDashboardUpdateInterval = 5;

  // Buffer sizes
  static const int defaultPerformanceBufferSize = 1000;
  static const int defaultErrorBufferSize = 1000;
  static const int defaultAbuseSignalBufferSize = 10000;

  // Thresholds
  static const int defaultCriticalErrorThreshold = 10;
  static const double defaultSpamThreshold = 0.7;
  static const double defaultHarassmentThreshold = 0.8;
  static const double defaultBotBehaviorThreshold = 0.75;

  // Retention periods (in days)
  static const int defaultErrorRetentionDays = 30;
  static const int defaultHealthDataRetentionDays = 90;
  static const int defaultPerformanceDataRetentionDays = 60;
  static const int defaultAbuseDataRetentionDays = 180;
}

/// Helper class for social monitoring operations (stub implementation)
class SocialMonitoringHelper {
  final dynamic healthMonitoring;
  final dynamic performanceMonitoring;
  final dynamic errorTracking;
  final dynamic abuseDetection;

  SocialMonitoringHelper({
    this.healthMonitoring,
    this.performanceMonitoring,
    this.errorTracking,
    this.abuseDetection,
  });

  /// Track an operation (stub implementation)
  Future<T> _trackOperation<T>(
    Future<T> Function() operationFunc, {
    required String feature,
    required String operation,
    required String userId,
    String? content,
    Map<String, dynamic>? metadata,
  }) async {
    return await operationFunc();
  }

  /// Track user action (stub implementation)
  void trackUserAction({
    required String userId,
    required String action,
    required String targetType,
    String? targetId,
    String? content,
    Map<String, dynamic>? metadata,
  }) {
  }
}
